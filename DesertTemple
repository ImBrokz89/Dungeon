local targetColor = BrickColor.new("Pine Cone")

local function applyColorToFolder(folder)
    if folder then
        for _, child in ipairs(folder:GetChildren()) do
            if child:IsA("BasePart") then
                child.BrickColor = targetColor
                child.Material = Enum.Material.SmoothPlastic
            elseif child:IsA("Model") then
                for _, part in ipairs(child:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.BrickColor = targetColor
                        part.Material = Enum.Material.SmoothPlastic
                    end
                end
            end
        end
    end
end

local function deleteDecorationsFolder()
    local decorationsFolder = workspace:FindFirstChild("Decorations")
    if decorationsFolder then
        decorationsFolder:Destroy()
    end
end

local function deleteRocksAndBarriers()
    local rocksFolder = workspace:FindFirstChild("Map"):FindFirstChild("Rocks")
    if rocksFolder then
        rocksFolder:Destroy()
    end

    local barrier = workspace.dungeon:FindFirstChild("room3"):FindFirstChild("barrier")
    if barrier then
        barrier:Destroy()
    end
end

deleteDecorationsFolder()
deleteRocksAndBarriers()

local function refreshColors()
    while true do
        local structuresFolder = workspace:FindFirstChild("Map"):FindFirstChild("Structures")
        if structuresFolder then
            applyColorToFolder(structuresFolder)
        end
        local rocksFolder = workspace:FindFirstChild("Map"):FindFirstChild("Rocks")
        if rocksFolder then
            applyColorToFolder(rocksFolder)
        end
        wait(5)
    end
end
spawn(refreshColors)
--
local player = game.Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- Paramètres
local SAFE_DISTANCE = 10
local OBSTACLE_AVOIDANCE_DISTANCE = 5
local OBSTACLE_CLEARANCE = 3
local OBSTACLE_CHECK_ANGLE = math.rad(45)
local WALK_SPEED = 20
local SKILL_COOLDOWN = 6
local TOOL_ACTIVATION_DISTANCE = 12

local ignoreObjects = {}

local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Blacklist

local function updateIgnoreObjects()
    table.insert(ignoreObjects, player.Character)

    local decorations = workspace:FindFirstChild("Decorations")
    if decorations then
        table.insert(ignoreObjects, decorations)
    end

    rayParams.FilterDescendantsInstances = ignoreObjects
end

local function detectObstacle(direction)
    local rayOrigin = player.Character.HumanoidRootPart.Position
    local rayDirection = direction * OBSTACLE_AVOIDANCE_DISTANCE

    local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
    if result then
        local hitPart = result.Instance
        if hitPart and hitPart.CanCollide then
            return true, hitPart
        end
    end
    return false, nil
end

local function adjustDirection(originalDirection)

    local leftDirection = CFrame.Angles(0, -OBSTACLE_CHECK_ANGLE, 0) * originalDirection
    local hasLeftObstacle, _ = detectObstacle(leftDirection)

    if not hasLeftObstacle then
        return leftDirection
    end

    local rightDirection = CFrame.Angles(0, OBSTACLE_CHECK_ANGLE, 0) * originalDirection
    local hasRightObstacle, _ = detectObstacle(rightDirection)

    if not hasRightObstacle then
        return rightDirection
    end

    return -originalDirection
end

local function findNearestEnemy()
    local nearestEnemy = nil
    local nearestDistance = math.huge

    for _, room in ipairs(workspace.dungeon:GetChildren()) do
        if room:FindFirstChild("enemyFolder") then
            for _, enemy in ipairs(room.enemyFolder:GetChildren()) do
                if enemy:FindFirstChild("HumanoidRootPart") and enemy:FindFirstChild("Humanoid") then
                    local distance = (player.Character.HumanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    return nearestEnemy
end

local function simulateKeyPress(key)
    local virtualInputManager = game:GetService("VirtualInputManager")
    virtualInputManager:SendKeyEvent(true, key, false, nil)
    wait(0.1)
    virtualInputManager:SendKeyEvent(false, key, false, nil)
end

local function activateToolOrSkill(distance)
    if distance <= TOOL_ACTIVATION_DISTANCE then
        simulateKeyPress(Enum.KeyCode.E)
        simulateKeyPress(Enum.KeyCode.Q)
    end
end

local function moveToEnemy(enemy)
    if enemy and enemy:FindFirstChild("HumanoidRootPart") then
        local enemyPosition = enemy.HumanoidRootPart.Position
        local playerPosition = player.Character.HumanoidRootPart.Position
        local distance = (playerPosition - enemyPosition).Magnitude

        local currentOrientation = player.Character.HumanoidRootPart.CFrame.LookVector
        local directionToEnemy = (enemyPosition - playerPosition).Unit
        local angleDiff = math.acos(currentOrientation:Dot(directionToEnemy))

        if angleDiff > 0.1 then
            player.Character.HumanoidRootPart.CFrame = CFrame.lookAt(playerPosition, Vector3.new(enemyPosition.X, playerPosition.Y, enemyPosition.Z))
        end

        local direction = (enemyPosition - playerPosition).Unit

        local hasObstacle, _ = detectObstacle(direction)
        if hasObstacle then
            print("Obstacle détecté, ajustement de la trajectoire...")
            direction = adjustDirection(direction)
        end

        if distance > SAFE_DISTANCE then
            local targetPosition = playerPosition + direction * (distance - SAFE_DISTANCE)
            player.Character.Humanoid:MoveTo(targetPosition)
        else
            local safeDirection = (playerPosition - enemyPosition).Unit
            local safePosition = playerPosition + safeDirection * (SAFE_DISTANCE - distance + 1)
            player.Character.Humanoid:MoveTo(safePosition)
        end

        activateToolOrSkill(distance)
    end
end

local function autoFarm()
    while true do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local nearestEnemy = findNearestEnemy()
            if nearestEnemy then
                moveToEnemy(nearestEnemy)
            end
        end
        wait(0.1)
    end
end

local function initializeCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")

    humanoid.WalkSpeed = WALK_SPEED

    humanoid.Died:Connect(function()
        print("Le joueur est mort. En attente de réapparition...")
    end)

    task.spawn(autoFarm)
end

player.CharacterAdded:Connect(function(character)
    print("Nouveau personnage détecté. Réinitialisation.")
    initializeCharacter(character)
end)

if player.Character then
    initializeCharacter(player.Character)
end

updateIgnoreObjects()
