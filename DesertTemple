local targetColor = BrickColor.new("Pine Cone")
local function applyColorToFolder(folder)
    if folder then
        for _, child in ipairs(folder:GetChildren()) do
            if child:IsA("BasePart") then
                child.BrickColor = targetColor
                child.Material = Enum.Material.SmoothPlastic
            elseif child:IsA("Model") then
                for _, part in ipairs(child:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.BrickColor = targetColor
                        part.Material = Enum.Material.SmoothPlastic
                    end
                end
            end
        end
    end
end

local function deleteDecorationsFolder()
    local decorationsFolder = workspace:FindFirstChild("Decorations")
    if decorationsFolder then
        decorationsFolder:Destroy()
    end
end
deleteDecorationsFolder()
local function refreshColors()
    while true do
        local structuresFolder = workspace:FindFirstChild("Map"):FindFirstChild("Structures")
        if structuresFolder then
            applyColorToFolder(structuresFolder)
        end
        local rocksFolder = workspace:FindFirstChild("Map"):FindFirstChild("Rocks")
        if rocksFolder then
            applyColorToFolder(rocksFolder)
        end
        wait(5) -- Rafraîchit toutes les 5 secondes
    end
end
spawn(refreshColors)
---
local player = game.Players.LocalPlayer

-- Paramètres
local SAFE_DISTANCE = 10
local OBSTACLE_AVOIDANCE_DISTANCE = 5
local OBSTACLE_CLEARANCE = 3 -- Distance utilisée pour contourner
local OBSTACLE_CHECK_ANGLE = math.rad(45) -- Angle pour ajuster la direction

-- Liste des objets à ignorer pour le raycast
local ignoreObjects = {}

-- Initialisation des paramètres du raycast
local rayParams = RaycastParams.new()
rayParams.FilterType = Enum.RaycastFilterType.Blacklist

-- Fonction pour mettre à jour les objets ignorés par le raycast
local function updateIgnoreObjects()
    table.insert(ignoreObjects, player.Character)

    local decorations = workspace:FindFirstChild("Decorations")
    if decorations then
        table.insert(ignoreObjects, decorations)
    end

    rayParams.FilterDescendantsInstances = ignoreObjects
end

-- Fonction pour détecter les obstacles dans une direction donnée
local function detectObstacle(direction)
    local rayOrigin = player.Character.HumanoidRootPart.Position
    local rayDirection = direction * OBSTACLE_AVOIDANCE_DISTANCE

    local result = workspace:Raycast(rayOrigin, rayDirection, rayParams)
    if result then
        local hitPart = result.Instance
        if hitPart and hitPart.CanCollide then
            return true, hitPart -- Obstacle détecté
        end
    end
    return false, nil -- Aucun obstacle
end

-- Fonction pour ajuster la trajectoire pour contourner un obstacle
local function adjustDirection(originalDirection)
    -- Essaie de contourner sur la gauche
    local leftDirection = CFrame.Angles(0, -OBSTACLE_CHECK_ANGLE, 0) * originalDirection
    local hasLeftObstacle, _ = detectObstacle(leftDirection)

    if not hasLeftObstacle then
        return leftDirection -- Pas d'obstacle à gauche, contourner par là
    end

    -- Si la gauche est bloquée, essaie de contourner sur la droite
    local rightDirection = CFrame.Angles(0, OBSTACLE_CHECK_ANGLE, 0) * originalDirection
    local hasRightObstacle, _ = detectObstacle(rightDirection)

    if not hasRightObstacle then
        return rightDirection -- Pas d'obstacle à droite, contourner par là
    end

    -- Si tout est bloqué, garde la direction originale (ou recalibre)
    return -originalDirection -- (Reculer si absolument nécessaire)
end

-- Fonction pour trouver l'ennemi le plus proche
local function findNearestEnemy()
    local nearestEnemy = nil
    local nearestDistance = math.huge

    for _, room in ipairs(workspace.dungeon:GetChildren()) do
        if room:FindFirstChild("enemyFolder") then
            for _, enemy in ipairs(room.enemyFolder:GetChildren()) do
                if enemy:FindFirstChild("HumanoidRootPart") and enemy:FindFirstChild("Humanoid") then
                    local distance = (player.Character.HumanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestEnemy = enemy
                    end
                end
            end
        end
    end

    return nearestEnemy
end

-- Fonction pour déplacer le joueur vers l'ennemi
local function moveToEnemy(enemy)
    if enemy and enemy:FindFirstChild("HumanoidRootPart") then
        local enemyPosition = enemy.HumanoidRootPart.Position
        local playerPosition = player.Character.HumanoidRootPart.Position
        local distance = (playerPosition - enemyPosition).Magnitude

        -- Oriente le joueur vers l'ennemi
        player.Character.HumanoidRootPart.CFrame = CFrame.lookAt(playerPosition, Vector3.new(enemyPosition.X, playerPosition.Y, enemyPosition.Z))

        local direction = (enemyPosition - playerPosition).Unit

        -- Vérifie s'il y a un obstacle dans la direction
        local hasObstacle, _ = detectObstacle(direction)
        if hasObstacle then
            print("Obstacle détecté, ajustement de la trajectoire...")
            direction = adjustDirection(direction) -- Ajuste la direction pour contourner
        end

        if distance > SAFE_DISTANCE then
            -- Se rapprocher de l'ennemi
            local targetPosition = playerPosition + direction * (distance - SAFE_DISTANCE)
            player.Character.Humanoid:MoveTo(targetPosition)
        else
            -- Maintenir une distance sécurisée
            local safeDirection = (playerPosition - enemyPosition).Unit
            local safePosition = playerPosition + safeDirection * (SAFE_DISTANCE - distance + 1)
            player.Character.Humanoid:MoveTo(safePosition)
        end
    end
end

-- Fonction principale de l'auto-farm
local function autoFarm()
    while true do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local nearestEnemy = findNearestEnemy()
            if nearestEnemy then
                moveToEnemy(nearestEnemy)
            end
        end
        wait(0.1)
    end
end

-- Fonction pour gérer la réapparition et continuer l'auto-farm
local function initializeCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")

    humanoid.Died:Connect(function()
        print("Le joueur est mort. En attente de réapparition...")
    end)

    -- Relancer l'auto-farm après la réapparition
    task.spawn(autoFarm)
end

-- Événement pour détecter la réapparition du personnage
player.CharacterAdded:Connect(function(character)
    print("Nouveau personnage détecté. Réinitialisation.")
    initializeCharacter(character)
end)

-- Initialisation lors du premier chargement
if player.Character then
    initializeCharacter(player.Character)
end

-- Met à jour la liste des objets à ignorer
updateIgnoreObjects()
